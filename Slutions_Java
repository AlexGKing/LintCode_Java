#1
给出两个整数a和b, 求他们的和, 但不能使用 + 等数学运算符。
提示：位操作

class Solution {
    /*
     * param a: The first integer
     * param b: The second integer
     * return: The sum of a and b
     */
    public int aplusb(int a, int b) {
        // write your code here, try to do it without arithmetic operators.
        int jw = a & b;
        int jg = a ^ b;
        while (jw>0){
            int ta = jg;
            int tb = jw << 1;
            jw = ta & tb;
            jg = ta ^ tb;
        }
        return jg;
    }
};

#2
设计一个算法，计算出n阶乘中尾部零的个数，例如：11! = 39916800，因此应该返回 2
要求：O(logN)的时间复杂度

class Solution {
    /*
     * param n: As desciption
     * return: An integer, denote the number of trailing zeros in n!
     */
    public long trailingZeros(long n) {
       long sum = 0;
        while (n != 0) {
            sum += n / 5;
            n /= 5;
        }
        return sum;
    }
};
#二分查找
给定一个排序的整数数组（升序）和一个要查找的整数target，用O(logn)的时间查找到target第一次出现的下标（从0开始,
如果target不存在于数组中，返回-1。
样例：在数组 [1, 2, 3, 3, 4, 5, 10] 中二分查找3，返回2。
标签：二分法，数组

class Solution {
    /**
     * @param nums: The integer array.
     * @param target: Target to find.
     * @return: The first position of target. Position starts from 0.
     */
    public int bs(int[] nums, int start,int end, int target) {
        if(start>end) {
            return -1;
        } else {
            int mid = (start + end) / 2;
            if(nums[mid] == target) {
                while(mid>0){
                    if(nums[mid] == nums[mid-1]){
                        mid--;
                    } else {
                        break;
                    }
                }
                return mid;
            } else if(nums[mid]>target) {
                return bs(nums,start,mid-1,target);
            } else {
                return bs(nums,mid+1,end,target);
            }
        }
    }
    public int binarySearch(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return -1;
        } else {
            return bs(nums,0,nums.length-1,target);
        }
    }
}
#55 比较字符串
比较两个字符串A和B，确定A中是否包含B中所有的字符。字符串A和B中的字符都是大写字母
样例：
给出 A = "ABCD" B = "ACD"，返回 true
给出 A = "ABCD" B = "AABC"， 返回 false
标签：字符串处理 hash

public class Solution {
    /**
     * @param A : A string includes Upper Case letters
     * @param B : A string includes Upper Case letter
     * @return :  if string A contains all of the characters in B return true else return false
     */
    public boolean compareStrings(String A, String B) {
        if(A == null && B == null){
            return true;
        } else if (A == null && B != null) {
            return false;
        } else if( A != null && B == null) {
            return true;
        } else {
            int[] alphabetA = new int[26];
            int[] alphabetB = new int[26];
            for (int i = 0; i < 26; i++) {
                alphabetA[i] = 0;
                alphabetB[i] = 0;
            }
            for (int i = 0; i < A.length(); i++) {
                alphabetA[A.charAt(i) - 'A']++;
            }
            for (int i = 0; i < B.length(); i++) {
                alphabetB[B.charAt(i) - 'A']++;
            }
            for(int i = 0; i < 26; i++){
                if(alphabetB[i] > alphabetA[i]) {
                    return false;
                }
            }
            return true;
        }
    }
}

#423 有效括号序列
给定一个字符串所表示的括号序列，包含以下字符： '(', ')', '{', '}', '[' and ']'， 判定是否是有效的括号序列。
样例：括号必须依照 "()" 顺序表示， "()[]{}" 是有效的括号，但 "([)]"则是无效的括号。
标签：栈
时间复杂度：O(n)的时间，n为括号的个数

public class Solution {
    /**
     * @param s A string
     * @return whether the string is a valid parentheses
     */
    public boolean isValidParentheses(String s) {
        if (s == null || s.equals("")){
            return true;
        } else {
            Stack stack = new Stack();
            for (int i = 0; i < s.length(); i++){
                if (stack.empty()) {
                    stack.push(s.charAt(i));
                } else {
                    if (s.charAt(i) == ')' && stack.peek() == '(' ){
                        stack.pop();
                    } else if (s.charAt(i) == ']' && stack.peek() == '[' ){
                        stack.pop();
                    } else if (s.charAt(i) == '}' && stack.peek() == '{' ){
                        stack.pop();
                    } else {
                        stack.push(s.charAt(i));
                    }
                }
            }
            return stack.empty();
        }
    }
}

#424 计算逆波兰表达式
在逆波兰表达法中，其有效的运算符号包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰计数表达。
示例：
["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6
标签：栈

public class Solution {
    /**
     * @param tokens The Reverse Polish Notation
     * @return the value
     */
    public int evalRPN(String[] tokens) {
       if(tokens == null){
           return 0;
       }else if(tokens.length == 0){
           return 0;
       }else{
           Stack stack =  new Stack();
           int n1 = 0;
           int n2 = 0;
           for ( int i = 0 ; i < tokens.length; i++) {
               if ( tokens[i].equals("+") ){
                   n1 = Integer.parseInt((String)stack.pop());
                   n2 = Integer.parseInt((String)stack.pop());
                   stack.push(String.valueOf(n1 + n2));
               } else if( tokens[i].equals("-") ) {
                   n1 = Integer.parseInt((String)stack.pop());
                   n2 = Integer.parseInt((String)stack.pop());
                   stack.push(String.valueOf(n2 - n1));
               } else if( tokens[i].equals("*") ) {
                   n1 = Integer.parseInt((String)stack.pop());
                   n2 = Integer.parseInt((String)stack.pop());
                   stack.push(String.valueOf(n2 * n1));
               } else if( tokens[i].equals("/") ) {
                   n1 = Integer.parseInt((String)stack.pop());
                   n2 = Integer.parseInt((String)stack.pop());
                   stack.push(String.valueOf(n2 / n1));
               } else{
                   stack.push(tokens[i]);
               }
           }
           return Integer.parseInt((String)stack.pop());
       }
    }
}

#用两个栈模拟队列

正如标题所述，你需要使用两个栈来实现队列的一些操作。

队列应支持push(element)，pop() 和 top()，其中pop是弹出队列中的第一个(最前面的)元素。

pop和top方法都应该返回第一个元素的值。
示例：比如push(1), pop(), push(2), push(3), top(), pop()，你应该返回1，2和2

标签：栈、队列


public class Queue {
    private Stack<Integer> stack1;
    private Stack<Integer> stack2;

    public Queue() {
       stack1 = new Stack<Integer>();
       stack2 = new Stack<Integer>();
    }
    
    public void push(int element) {
        if (stack2.empty()) {
            stack1.push(element);
        } else {
            while(!stack2.empty()) {
                stack1.push(stack2.pop());
            }
            stack1.push(element);
        }
    }

    public int pop() {
        if (!stack2.empty()) {
            return stack2.pop();
        } else {
            while (!stack1.empty()) {
                stack2.push(stack1.pop());
            }
            return stack2.pop();
        }
    }

    public int top() {
        if (!stack2.empty()) {
            return stack2.peek();
        } else {
            while (!stack1.empty()) {
                stack2.push(stack1.pop());
            }
            return stack2.peek();
        }
    }
}
