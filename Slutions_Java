#1
给出两个整数a和b, 求他们的和, 但不能使用 + 等数学运算符。
提示：位操作

class Solution {
    /*
     * param a: The first integer
     * param b: The second integer
     * return: The sum of a and b
     */
    public int aplusb(int a, int b) {
        // write your code here, try to do it without arithmetic operators.
        int jw = a & b;
        int jg = a ^ b;
        while (jw>0){
            int ta = jg;
            int tb = jw << 1;
            jw = ta & tb;
            jg = ta ^ tb;
        }
        return jg;
    }
};

#2
设计一个算法，计算出n阶乘中尾部零的个数，例如：11! = 39916800，因此应该返回 2
要求：O(logN)的时间复杂度

class Solution {
    /*
     * param n: As desciption
     * return: An integer, denote the number of trailing zeros in n!
     */
    public long trailingZeros(long n) {
       long sum = 0;
        while (n != 0) {
            sum += n / 5;
            n /= 5;
        }
        return sum;
    }
};

#423 有效括号序列
给定一个字符串所表示的括号序列，包含以下字符： '(', ')', '{', '}', '[' and ']'， 判定是否是有效的括号序列。
样例：括号必须依照 "()" 顺序表示， "()[]{}" 是有效的括号，但 "([)]"则是无效的括号。
标签：栈
时间复杂度：O(n)的时间，n为括号的个数

public class Solution {
    /**
     * @param s A string
     * @return whether the string is a valid parentheses
     */
    public boolean isValidParentheses(String s) {
        if (s == null || s.equals("")){
            return true;
        } else {
            Stack stack = new Stack();
            for (int i = 0; i < s.length(); i++){
                if (stack.empty()) {
                    stack.push(s.charAt(i));
                } else {
                    if (s.charAt(i) == ')' && stack.peek() == '(' ){
                        stack.pop();
                    } else if (s.charAt(i) == ']' && stack.peek() == '[' ){
                        stack.pop();
                    } else if (s.charAt(i) == '}' && stack.peek() == '{' ){
                        stack.pop();
                    } else {
                        stack.push(s.charAt(i));
                    }
                }
            }
            return stack.empty();
        }
    }
}

#424 计算逆波兰表达式
在逆波兰表达法中，其有效的运算符号包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰计数表达。
示例：
["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6
标签：栈

public class Solution {
    /**
     * @param tokens The Reverse Polish Notation
     * @return the value
     */
    public int evalRPN(String[] tokens) {
       if(tokens == null){
           return 0;
       }else if(tokens.length == 0){
           return 0;
       }else{
           Stack stack =  new Stack();
           int n1 = 0;
           int n2 = 0;
           for ( int i = 0 ; i < tokens.length; i++) {
               if ( tokens[i].equals("+") ){
                   n1 = Integer.parseInt((String)stack.pop());
                   n2 = Integer.parseInt((String)stack.pop());
                   stack.push(String.valueOf(n1 + n2));
               } else if( tokens[i].equals("-") ) {
                   n1 = Integer.parseInt((String)stack.pop());
                   n2 = Integer.parseInt((String)stack.pop());
                   stack.push(String.valueOf(n2 - n1));
               } else if( tokens[i].equals("*") ) {
                   n1 = Integer.parseInt((String)stack.pop());
                   n2 = Integer.parseInt((String)stack.pop());
                   stack.push(String.valueOf(n2 * n1));
               } else if( tokens[i].equals("/") ) {
                   n1 = Integer.parseInt((String)stack.pop());
                   n2 = Integer.parseInt((String)stack.pop());
                   stack.push(String.valueOf(n2 / n1));
               } else{
                   stack.push(tokens[i]);
               }
           }
           return Integer.parseInt((String)stack.pop());
       }
    }
}
